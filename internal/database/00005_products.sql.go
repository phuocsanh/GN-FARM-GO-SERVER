// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: 00005_products.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
)

const countAllPublishedProducts = `-- name: CountAllPublishedProducts :one
SELECT COUNT(*) FROM products
WHERE is_published = true
`

func (q *Queries) CountAllPublishedProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllPublishedProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductsByType = `-- name: CountProductsByType :one
SELECT COUNT(*) FROM products
WHERE product_type = ? AND is_published = true
`

func (q *Queries) CountProductsByType(ctx context.Context, productType string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProductsByType, productType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchProductsByName = `-- name: CountSearchProductsByName :one
SELECT COUNT(*) FROM products
WHERE product_name LIKE ? AND is_published = true
`

func (q *Queries) CountSearchProductsByName(ctx context.Context, productName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchProductsByName, productName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBonsai = `-- name: CreateBonsai :execresult
INSERT INTO bonsais (
    id, product_shop, age, height, style, species, pot_type
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
`

type CreateBonsaiParams struct {
	ID          string
	ProductShop string
	Age         sql.NullInt32
	Height      sql.NullInt32
	Style       sql.NullString
	Species     sql.NullString
	PotType     sql.NullString
}

func (q *Queries) CreateBonsai(ctx context.Context, arg CreateBonsaiParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createBonsai,
		arg.ID,
		arg.ProductShop,
		arg.Age,
		arg.Height,
		arg.Style,
		arg.Species,
		arg.PotType,
	)
}

const createInventory = `-- name: CreateInventory :execresult
INSERT INTO inventory (
    product_id, shop_id, location, stock
) VALUES (
    ?, ?, ?, ?
)
`

type CreateInventoryParams struct {
	ProductID string
	ShopID    string
	Location  sql.NullString
	Stock     int32
}

func (q *Queries) CreateInventory(ctx context.Context, arg CreateInventoryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createInventory,
		arg.ProductID,
		arg.ShopID,
		arg.Location,
		arg.Stock,
	)
}

const createMushroom = `-- name: CreateMushroom :execresult
INSERT INTO mushrooms (
    id, product_shop, weight, origin, freshness, package_type
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateMushroomParams struct {
	ID          string
	ProductShop string
	Weight      sql.NullString
	Origin      sql.NullString
	Freshness   sql.NullString
	PackageType sql.NullString
}

func (q *Queries) CreateMushroom(ctx context.Context, arg CreateMushroomParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createMushroom,
		arg.ID,
		arg.ProductShop,
		arg.Weight,
		arg.Origin,
		arg.Freshness,
		arg.PackageType,
	)
}

const createProduct = `-- name: CreateProduct :execresult
INSERT INTO products (
    id, product_name, product_price, product_discounted_price, 
    product_thumb, product_description, product_quantity, 
    product_type, sub_product_type, product_videos, 
    product_pictures, product_status, product_shop, 
    is_draft, is_published
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateProductParams struct {
	ID                     string
	ProductName            string
	ProductPrice           string
	ProductDiscountedPrice sql.NullString
	ProductThumb           sql.NullString
	ProductDescription     sql.NullString
	ProductQuantity        int32
	ProductType            string
	SubProductType         sql.NullString
	ProductVideos          json.RawMessage
	ProductPictures        json.RawMessage
	ProductStatus          string
	ProductShop            string
	IsDraft                bool
	IsPublished            bool
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProduct,
		arg.ID,
		arg.ProductName,
		arg.ProductPrice,
		arg.ProductDiscountedPrice,
		arg.ProductThumb,
		arg.ProductDescription,
		arg.ProductQuantity,
		arg.ProductType,
		arg.SubProductType,
		arg.ProductVideos,
		arg.ProductPictures,
		arg.ProductStatus,
		arg.ProductShop,
		arg.IsDraft,
		arg.IsPublished,
	)
}

const createVegetable = `-- name: CreateVegetable :execresult
INSERT INTO vegetables (
    id, product_shop, weight, origin, freshness, package_type
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateVegetableParams struct {
	ID          string
	ProductShop string
	Weight      sql.NullString
	Origin      sql.NullString
	Freshness   sql.NullString
	PackageType sql.NullString
}

func (q *Queries) CreateVegetable(ctx context.Context, arg CreateVegetableParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createVegetable,
		arg.ID,
		arg.ProductShop,
		arg.Weight,
		arg.Origin,
		arg.Freshness,
		arg.PackageType,
	)
}

const getBonsaiByID = `-- name: GetBonsaiByID :one
SELECT id, product_shop, age, height, style, species, pot_type, created_at, updated_at FROM bonsais
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBonsaiByID(ctx context.Context, id string) (Bonsai, error) {
	row := q.db.QueryRowContext(ctx, getBonsaiByID, id)
	var i Bonsai
	err := row.Scan(
		&i.ID,
		&i.ProductShop,
		&i.Age,
		&i.Height,
		&i.Style,
		&i.Species,
		&i.PotType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMushroomByID = `-- name: GetMushroomByID :one
SELECT id, product_shop, weight, origin, freshness, package_type, created_at, updated_at FROM mushrooms
WHERE id = ? LIMIT 1
`

func (q *Queries) GetMushroomByID(ctx context.Context, id string) (Mushroom, error) {
	row := q.db.QueryRowContext(ctx, getMushroomByID, id)
	var i Mushroom
	err := row.Scan(
		&i.ID,
		&i.ProductShop,
		&i.Weight,
		&i.Origin,
		&i.Freshness,
		&i.PackageType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, product_name, product_price, product_discounted_price, product_thumb, product_description, product_quantity, product_type, sub_product_type, product_videos, product_pictures, product_status, product_selled, product_shop, is_draft, is_published, created_at, updated_at FROM products
WHERE id = ? LIMIT 1
`

func (q *Queries) GetProductByID(ctx context.Context, id string) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.ProductPrice,
		&i.ProductDiscountedPrice,
		&i.ProductThumb,
		&i.ProductDescription,
		&i.ProductQuantity,
		&i.ProductType,
		&i.SubProductType,
		&i.ProductVideos,
		&i.ProductPictures,
		&i.ProductStatus,
		&i.ProductSelled,
		&i.ProductShop,
		&i.IsDraft,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVegetableByID = `-- name: GetVegetableByID :one
SELECT id, product_shop, weight, origin, freshness, package_type, created_at, updated_at FROM vegetables
WHERE id = ? LIMIT 1
`

func (q *Queries) GetVegetableByID(ctx context.Context, id string) (Vegetable, error) {
	row := q.db.QueryRowContext(ctx, getVegetableByID, id)
	var i Vegetable
	err := row.Scan(
		&i.ID,
		&i.ProductShop,
		&i.Weight,
		&i.Origin,
		&i.Freshness,
		&i.PackageType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllPublishedProducts = `-- name: ListAllPublishedProducts :many
SELECT id, product_name, product_price, product_discounted_price, product_thumb, product_description, product_quantity, product_type, sub_product_type, product_videos, product_pictures, product_status, product_selled, product_shop, is_draft, is_published, created_at, updated_at FROM products
WHERE is_published = true
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAllPublishedProductsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListAllPublishedProducts(ctx context.Context, arg ListAllPublishedProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listAllPublishedProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductDiscountedPrice,
			&i.ProductThumb,
			&i.ProductDescription,
			&i.ProductQuantity,
			&i.ProductType,
			&i.SubProductType,
			&i.ProductVideos,
			&i.ProductPictures,
			&i.ProductStatus,
			&i.ProductSelled,
			&i.ProductShop,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDraftProducts = `-- name: ListDraftProducts :many
SELECT id, product_name, product_price, product_discounted_price, product_thumb, product_description, product_quantity, product_type, sub_product_type, product_videos, product_pictures, product_status, product_selled, product_shop, is_draft, is_published, created_at, updated_at FROM products
WHERE product_shop = ? AND is_draft = true
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListDraftProductsParams struct {
	ProductShop string
	Limit       int32
	Offset      int32
}

func (q *Queries) ListDraftProducts(ctx context.Context, arg ListDraftProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listDraftProducts, arg.ProductShop, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductDiscountedPrice,
			&i.ProductThumb,
			&i.ProductDescription,
			&i.ProductQuantity,
			&i.ProductType,
			&i.SubProductType,
			&i.ProductVideos,
			&i.ProductPictures,
			&i.ProductStatus,
			&i.ProductSelled,
			&i.ProductShop,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByDiscount = `-- name: ListProductsByDiscount :many
SELECT id, product_name, product_price, product_discounted_price, product_thumb, product_description, product_quantity, product_type, sub_product_type, product_videos, product_pictures, product_status, product_selled, product_shop, is_draft, is_published, created_at, updated_at FROM products
WHERE is_published = true
ORDER BY product_discounted_price DESC
LIMIT ? OFFSET ?
`

type ListProductsByDiscountParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListProductsByDiscount(ctx context.Context, arg ListProductsByDiscountParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProductsByDiscount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductDiscountedPrice,
			&i.ProductThumb,
			&i.ProductDescription,
			&i.ProductQuantity,
			&i.ProductType,
			&i.SubProductType,
			&i.ProductVideos,
			&i.ProductPictures,
			&i.ProductStatus,
			&i.ProductSelled,
			&i.ProductShop,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsBySelled = `-- name: ListProductsBySelled :many
SELECT id, product_name, product_price, product_discounted_price, product_thumb, product_description, product_quantity, product_type, sub_product_type, product_videos, product_pictures, product_status, product_selled, product_shop, is_draft, is_published, created_at, updated_at FROM products
WHERE is_published = true
ORDER BY product_selled DESC
LIMIT ? OFFSET ?
`

type ListProductsBySelledParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListProductsBySelled(ctx context.Context, arg ListProductsBySelledParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProductsBySelled, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductDiscountedPrice,
			&i.ProductThumb,
			&i.ProductDescription,
			&i.ProductQuantity,
			&i.ProductType,
			&i.SubProductType,
			&i.ProductVideos,
			&i.ProductPictures,
			&i.ProductStatus,
			&i.ProductSelled,
			&i.ProductShop,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByType = `-- name: ListProductsByType :many
SELECT id, product_name, product_price, product_discounted_price, product_thumb, product_description, product_quantity, product_type, sub_product_type, product_videos, product_pictures, product_status, product_selled, product_shop, is_draft, is_published, created_at, updated_at FROM products
WHERE product_type = ? AND is_published = true
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListProductsByTypeParams struct {
	ProductType string
	Limit       int32
	Offset      int32
}

func (q *Queries) ListProductsByType(ctx context.Context, arg ListProductsByTypeParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProductsByType, arg.ProductType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductDiscountedPrice,
			&i.ProductThumb,
			&i.ProductDescription,
			&i.ProductQuantity,
			&i.ProductType,
			&i.SubProductType,
			&i.ProductVideos,
			&i.ProductPictures,
			&i.ProductStatus,
			&i.ProductSelled,
			&i.ProductShop,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedProducts = `-- name: ListPublishedProducts :many
SELECT id, product_name, product_price, product_discounted_price, product_thumb, product_description, product_quantity, product_type, sub_product_type, product_videos, product_pictures, product_status, product_selled, product_shop, is_draft, is_published, created_at, updated_at FROM products
WHERE product_shop = ? AND is_published = true
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPublishedProductsParams struct {
	ProductShop string
	Limit       int32
	Offset      int32
}

func (q *Queries) ListPublishedProducts(ctx context.Context, arg ListPublishedProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedProducts, arg.ProductShop, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductDiscountedPrice,
			&i.ProductThumb,
			&i.ProductDescription,
			&i.ProductQuantity,
			&i.ProductType,
			&i.SubProductType,
			&i.ProductVideos,
			&i.ProductPictures,
			&i.ProductStatus,
			&i.ProductSelled,
			&i.ProductShop,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishProduct = `-- name: PublishProduct :execresult
UPDATE products
SET is_draft = false, is_published = true
WHERE id = ? AND product_shop = ?
`

type PublishProductParams struct {
	ID          string
	ProductShop string
}

func (q *Queries) PublishProduct(ctx context.Context, arg PublishProductParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, publishProduct, arg.ID, arg.ProductShop)
}

const searchProductsByName = `-- name: SearchProductsByName :many
SELECT id, product_name, product_price, product_discounted_price, product_thumb, product_description, product_quantity, product_type, sub_product_type, product_videos, product_pictures, product_status, product_selled, product_shop, is_draft, is_published, created_at, updated_at FROM products
WHERE product_name LIKE ? AND is_published = true
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type SearchProductsByNameParams struct {
	ProductName string
	Limit       int32
	Offset      int32
}

func (q *Queries) SearchProductsByName(ctx context.Context, arg SearchProductsByNameParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, searchProductsByName, arg.ProductName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductDiscountedPrice,
			&i.ProductThumb,
			&i.ProductDescription,
			&i.ProductQuantity,
			&i.ProductType,
			&i.SubProductType,
			&i.ProductVideos,
			&i.ProductPictures,
			&i.ProductStatus,
			&i.ProductSelled,
			&i.ProductShop,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unpublishProduct = `-- name: UnpublishProduct :execresult
UPDATE products
SET is_draft = true, is_published = false
WHERE id = ? AND product_shop = ?
`

type UnpublishProductParams struct {
	ID          string
	ProductShop string
}

func (q *Queries) UnpublishProduct(ctx context.Context, arg UnpublishProductParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, unpublishProduct, arg.ID, arg.ProductShop)
}

const updateBonsai = `-- name: UpdateBonsai :execresult
UPDATE bonsais
SET 
    age = COALESCE(?, age),
    height = COALESCE(?, height),
    style = COALESCE(NULLIF(?, ''), style),
    species = COALESCE(NULLIF(?, ''), species),
    pot_type = COALESCE(NULLIF(?, ''), pot_type)
WHERE id = ? AND product_shop = ?
`

type UpdateBonsaiParams struct {
	Age         sql.NullInt32
	Height      sql.NullInt32
	NULLIF      interface{}
	NULLIF_2    interface{}
	NULLIF_3    interface{}
	ID          string
	ProductShop string
}

func (q *Queries) UpdateBonsai(ctx context.Context, arg UpdateBonsaiParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateBonsai,
		arg.Age,
		arg.Height,
		arg.NULLIF,
		arg.NULLIF_2,
		arg.NULLIF_3,
		arg.ID,
		arg.ProductShop,
	)
}

const updateMushroom = `-- name: UpdateMushroom :execresult
UPDATE mushrooms
SET 
    weight = COALESCE(?, weight),
    origin = COALESCE(NULLIF(?, ''), origin),
    freshness = COALESCE(NULLIF(?, ''), freshness),
    package_type = COALESCE(NULLIF(?, ''), package_type)
WHERE id = ? AND product_shop = ?
`

type UpdateMushroomParams struct {
	Weight      sql.NullString
	NULLIF      interface{}
	NULLIF_2    interface{}
	NULLIF_3    interface{}
	ID          string
	ProductShop string
}

func (q *Queries) UpdateMushroom(ctx context.Context, arg UpdateMushroomParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateMushroom,
		arg.Weight,
		arg.NULLIF,
		arg.NULLIF_2,
		arg.NULLIF_3,
		arg.ID,
		arg.ProductShop,
	)
}

const updateProduct = `-- name: UpdateProduct :execresult
UPDATE products
SET 
    product_name = COALESCE(NULLIF(?, ''), product_name),
    product_price = COALESCE(NULLIF(?, 0), product_price),
    product_discounted_price = COALESCE(?, product_discounted_price),
    product_thumb = COALESCE(NULLIF(?, ''), product_thumb),
    product_description = COALESCE(NULLIF(?, ''), product_description),
    product_quantity = COALESCE(NULLIF(?, 0), product_quantity),
    sub_product_type = COALESCE(NULLIF(?, ''), sub_product_type),
    product_videos = COALESCE(?, product_videos),
    product_pictures = COALESCE(?, product_pictures),
    product_status = COALESCE(NULLIF(?, ''), product_status)
WHERE id = ? AND product_shop = ?
`

type UpdateProductParams struct {
	NULLIF                 interface{}
	NULLIF_2               interface{}
	ProductDiscountedPrice sql.NullString
	NULLIF_3               interface{}
	NULLIF_4               interface{}
	NULLIF_5               interface{}
	NULLIF_6               interface{}
	ProductVideos          json.RawMessage
	ProductPictures        json.RawMessage
	NULLIF_7               interface{}
	ID                     string
	ProductShop            string
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateProduct,
		arg.NULLIF,
		arg.NULLIF_2,
		arg.ProductDiscountedPrice,
		arg.NULLIF_3,
		arg.NULLIF_4,
		arg.NULLIF_5,
		arg.NULLIF_6,
		arg.ProductVideos,
		arg.ProductPictures,
		arg.NULLIF_7,
		arg.ID,
		arg.ProductShop,
	)
}

const updateVegetable = `-- name: UpdateVegetable :execresult
UPDATE vegetables
SET 
    weight = COALESCE(?, weight),
    origin = COALESCE(NULLIF(?, ''), origin),
    freshness = COALESCE(NULLIF(?, ''), freshness),
    package_type = COALESCE(NULLIF(?, ''), package_type)
WHERE id = ? AND product_shop = ?
`

type UpdateVegetableParams struct {
	Weight      sql.NullString
	NULLIF      interface{}
	NULLIF_2    interface{}
	NULLIF_3    interface{}
	ID          string
	ProductShop string
}

func (q *Queries) UpdateVegetable(ctx context.Context, arg UpdateVegetableParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateVegetable,
		arg.Weight,
		arg.NULLIF,
		arg.NULLIF_2,
		arg.NULLIF_3,
		arg.ID,
		arg.ProductShop,
	)
}
